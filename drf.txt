# =======================
# settings.py
# =======================
"""
Django settings for blog project.
This file contains all the configuration for our Django project.
"""

import os
from pathlib import Path
from datetime import timedelta

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'your-secret-key-change-in-production'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []

# Application definition
# These are all the apps that Django will recognize
INSTALLED_APPS = [
    'django.contrib.admin',          # Admin interface
    'django.contrib.auth',           # Authentication system
    'django.contrib.contenttypes',   # Content type system
    'django.contrib.sessions',       # Session framework
    'django.contrib.messages',       # Messaging framework
    'django.contrib.staticfiles',    # Static file handling
    
    # Third-party apps
    'rest_framework',                # Django REST Framework
    'rest_framework_simplejwt',      # JWT authentication
    'corsheaders',                   # CORS headers for frontend
    'django_filters',                # Filtering support
    
    # Our custom app
    'blog',                          # Our main blog application
]

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',     # Must be at the top
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'blog_project.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'blog_project.wsgi.application'

# Database configuration
# Using SQLite for development (change to PostgreSQL/MySQL for production)
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}

# Password validation
AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

# Internationalization
LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
USE_I18N = True
USE_TZ = True

# Static files (CSS, JavaScript, Images)
STATIC_URL = '/static/'
STATICFILES_DIRS = [BASE_DIR / 'static']

# Media files (User uploaded content)
MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'media'

# Default primary key field type
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# Use our custom user model instead of Django's default User model
AUTH_USER_MODEL = 'blog.CustomUser'

# Django REST Framework configuration
REST_FRAMEWORK = {
    # Authentication classes determine how users authenticate
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ],
    
    # Permission classes determine what authenticated users can do
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
    
    # Pagination settings - how many items per page
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 10,
    
    # Filtering backend for search functionality
    'DEFAULT_FILTER_BACKENDS': [
        'django_filters.rest_framework.DjangoFilterBackend',
        'rest_framework.filters.SearchFilter',
        'rest_framework.filters.OrderingFilter',
    ],
}

# JWT Configuration
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=60),      # Access token expires in 1 hour
    'REFRESH_TOKEN_LIFETIME': timedelta(days=7),         # Refresh token expires in 7 days
    'ROTATE_REFRESH_TOKENS': True,                       # Generate new refresh token on use
    'BLACKLIST_AFTER_ROTATION': True,                    # Blacklist old refresh tokens
    'UPDATE_LAST_LOGIN': True,                           # Update last login time
    
    'ALGORITHM': 'HS256',                                # Signing algorithm
    'SIGNING_KEY': SECRET_KEY,                           # Key used to sign tokens
    'VERIFYING_KEY': None,
    'AUDIENCE': None,
    'ISSUER': None,
    
    'AUTH_HEADER_TYPES': ('Bearer',),                    # Token prefix in Authorization header
    'AUTH_HEADER_NAME': 'HTTP_AUTHORIZATION',
    'USER_ID_FIELD': 'id',
    'USER_ID_CLAIM': 'user_id',
    'USER_AUTHENTICATION_RULE': 'rest_framework_simplejwt.authentication.default_user_authentication_rule',
    
    'AUTH_TOKEN_CLASSES': ('rest_framework_simplejwt.tokens.AccessToken',),
    'TOKEN_TYPE_CLAIM': 'token_type',
    'TOKEN_USER_CLASS': 'rest_framework_simplejwt.models.TokenUser',
    
    'JTI_CLAIM': 'jti',
}

# CORS settings - allows frontend to make requests to our API
CORS_ALLOWED_ORIGINS = [
    "http://localhost:3000",      # React default port
    "http://127.0.0.1:3000",
    "http://localhost:8080",      # Vue default port
    "http://127.0.0.1:8080",
]

CORS_ALLOW_CREDENTIALS = True

# =======================
# blog_project/urls.py
# =======================
"""
Main URL configuration for blog_project.
This is the root URL configuration that includes all app URLs.
"""

from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    # Admin interface - accessible at /admin/
    path('admin/', admin.site.urls),
    
    # API endpoints - all our API will be under /api/
    path('api/', include('blog.urls')),
]

# Serve media files during development
# In production, you'd serve these through nginx or Apache
if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

# =======================
# blog/models.py
# =======================
"""
Models define the structure of our database tables.
Each model class represents a table in the database.
"""

from django.contrib.auth.models import AbstractUser
from django.db import models
from django.conf import settings

class CustomUser(AbstractUser):
    """
    Custom User model extending Django's AbstractUser.
    This allows us to add custom fields to the user model.
    """
    # Make email unique and required
    email = models.EmailField(unique=True)
    
    # Additional user fields
    bio = models.TextField(max_length=500, blank=True, help_text="User's biography")
    profile_picture = models.ImageField(
        upload_to='profiles/', 
        blank=True, 
        null=True,
        help_text="User's profile picture"
    )
    
    # Timestamps
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    # Use email as the unique identifier for authentication
    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = ['username']  # Fields required when creating superuser

    def __str__(self):
        return self.email

    class Meta:
        verbose_name = "User"
        verbose_name_plural = "Users"

class Post(models.Model):
    """
    Post model represents blog posts created by users.
    """
    # Foreign key to User - creates a many-to-one relationship
    # When user is deleted, their posts are also deleted (CASCADE)
    author = models.ForeignKey(
        settings.AUTH_USER_MODEL, 
        on_delete=models.CASCADE, 
        related_name='posts',
        help_text="The user who created this post"
    )
    
    # Post content
    title = models.CharField(max_length=200, help_text="Post title")
    image = models.ImageField(
        upload_to='posts/', 
        blank=True, 
        null=True,
        help_text="Optional post image"
    )
    caption = models.TextField(max_length=2000, help_text="Post content/caption")
    
    # Timestamps - auto_now_add sets the time when object is created
    # auto_now updates the time every time the object is saved
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        # Default ordering - newest posts first
        ordering = ['-created_at']
        verbose_name = "Post"
        verbose_name_plural = "Posts"

    def __str__(self):
        return f"{self.author.username}: {self.title}"

    @property
    def likes_count(self):
        """Property to get the number of likes for this post"""
        return self.likes.count()

    @property
    def comments_count(self):
        """Property to get the number of comments for this post"""
        return self.comments.count()

class Like(models.Model):
    """
    Like model represents likes on posts.
    A user can only like a post once (unique_together constraint).
    """
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL, 
        on_delete=models.CASCADE,
        help_text="User who liked the post"
    )
    post = models.ForeignKey(
        Post, 
        on_delete=models.CASCADE, 
        related_name='likes',
        help_text="Post that was liked"
    )
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        # Ensure a user can only like a post once
        unique_together = ('user', 'post')
        verbose_name = "Like"
        verbose_name_plural = "Likes"

    def __str__(self):
        return f"{self.user.username} likes {self.post.title}"

class Comment(models.Model):
    """
    Comment model represents comments on posts.
    """
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL, 
        on_delete=models.CASCADE,
        help_text="User who made the comment"
    )
    post = models.ForeignKey(
        Post, 
        on_delete=models.CASCADE, 
        related_name='comments',
        help_text="Post that was commented on"
    )
    content = models.TextField(max_length=1000, help_text="Comment content")
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ['-created_at']  # Newest comments first
        verbose_name = "Comment"
        verbose_name_plural = "Comments"

    def __str__(self):
        return f"{self.user.username} on {self.post.title}: {self.content[:50]}"

# =======================
# blog/serializers.py
# =======================
"""
Serializers convert Django model instances to JSON and vice versa.
They handle validation and define what fields are exposed in the API.
"""

from rest_framework import serializers
from django.contrib.auth import authenticate
from django.contrib.auth.password_validation import validate_password
from .models import CustomUser, Post, Like, Comment

class UserRegistrationSerializer(serializers.ModelSerializer):
    """
    Serializer for user registration.
    Handles password validation and user creation.
    """
    # write_only=True means this field won't be returned in responses
    password = serializers.CharField(
        write_only=True, 
        validators=[validate_password],  # Use Django's password validation
        help_text="Password must be at least 8 characters long"
    )
    password_confirm = serializers.CharField(
        write_only=True,
        help_text="Confirm your password"
    )

    class Meta:
        model = CustomUser
        fields = ('username', 'email', 'password', 'password_confirm', 'bio', 'profile_picture')

    def validate(self, attrs):
        """
        Custom validation to ensure passwords match.
        This method is called automatically by DRF.
        """
        if attrs['password'] != attrs['password_confirm']:
            raise serializers.ValidationError("Passwords don't match")
        return attrs

    def create(self, validated_data):
        """
        Create a new user with encrypted password.
        The password_confirm field is removed before creating the user.
        """
        validated_data.pop('password_confirm')  # Remove confirm password
        # create_user method automatically hashes the password
        user = CustomUser.objects.create_user(**validated_data)
        return user

class UserLoginSerializer(serializers.Serializer):
    """
    Serializer for user login.
    Validates credentials and returns the authenticated user.
    """
    email = serializers.EmailField()
    password = serializers.CharField(write_only=True)

    def validate(self, attrs):
        """
        Validate user credentials.
        """
        email = attrs.get('email')
        password = attrs.get('password')

        if email and password:
            # authenticate() checks if the credentials are valid
            user = authenticate(username=email, password=password)
            if not user:
                raise serializers.ValidationError('Invalid email or password')
            if not user.is_active:
                raise serializers.ValidationError('User account is disabled')
            attrs['user'] = user
        else:
            raise serializers.ValidationError('Must include email and password')
        return attrs

class UserSerializer(serializers.ModelSerializer):
    """
    Serializer for user profile information.
    Used for displaying user data and updating profiles.
    """
    # Make the posts_count available in user serialization
    posts_count = serializers.SerializerMethodField()

    class Meta:
        model = CustomUser
        fields = ('id', 'username', 'email', 'bio', 'profile_picture', 
                 'date_joined', 'posts_count')
        read_only_fields = ('id', 'date_joined')  # These fields can't be modified

    def get_posts_count(self, obj):
        """Method to calculate user's post count"""
        return obj.posts.count()

class CommentSerializer(serializers.ModelSerializer):
    """
    Serializer for comments.
    Includes user information for each comment.
    """
    user = UserSerializer(read_only=True)  # Nested serializer for user info

    class Meta:
        model = Comment
        fields = ('id', 'user', 'content', 'created_at', 'updated_at')
        read_only_fields = ('id', 'created_at', 'updated_at')

class PostSerializer(serializers.ModelSerializer):
    """
    Serializer for posts.
    Includes nested relationships and computed fields.
    """
    author = UserSerializer(read_only=True)  # Nested user info
    likes_count = serializers.ReadOnlyField()  # From model property
    comments_count = serializers.ReadOnlyField()  # From model property
    comments = CommentSerializer(many=True, read_only=True)  # All comments
    is_liked = serializers.SerializerMethodField()  # Custom field

    class Meta:
        model = Post
        fields = ('id', 'author', 'title', 'image', 'caption', 'created_at', 
                 'updated_at', 'likes_count', 'comments_count', 'comments', 'is_liked')
        read_only_fields = ('id', 'created_at', 'updated_at')

    def get_is_liked(self, obj):
        """
        Check if the current user has liked this post.
        SerializerMethodField automatically calls methods starting with 'get_'
        """
        request = self.context.get('request')
        if request and request.user.is_authenticated:
            return obj.likes.filter(user=request.user).exists()
        return False

class LikeSerializer(serializers.ModelSerializer):
    """
    Serializer for likes.
    Simple serializer as likes don't have much data.
    """
    user = UserSerializer(read_only=True)

    class Meta:
        model = Like
        fields = ('id', 'user', 'post', 'created_at')
        read_only_fields = ('id', 'user', 'created_at')

# =======================
# blog/permissions.py
# =======================
"""
Custom permissions for our API.
Permissions determine who can perform what actions.
"""

from rest_framework import permissions

class IsAuthorOrReadOnly(permissions.BasePermission):
    """
    Custom permission to only allow authors to edit their own content.
    
    This permission class checks:
    - Anyone can read (GET, HEAD, OPTIONS)
    - Only the author can modify (POST, PUT, PATCH, DELETE)
    """

    def has_object_permission(self, request, view, obj):
        """
        Object-level permission check.
        Called for each individual object (post, comment, etc.)
        """
        # Read permissions for all users
        if request.method in permissions.SAFE_METHODS:
            return True

        # Write permissions only for the author
        # Check if the object has an 'author' field (for Posts)
        if hasattr(obj, 'author'):
            return obj.author == request.user
        # Check if the object has a 'user' field (for Comments, Likes)
        elif hasattr(obj, 'user'):
            return obj.user == request.user
        
        return False

# =======================
# blog/filters.py
# =======================
"""
Custom filters for search and filtering functionality.
"""

import django_filters
from .models import Post, CustomUser

class PostFilter(django_filters.FilterSet):
    """
    Filter class for Post model.
    Allows filtering posts by various criteria.
    """
    # Filter by title containing text (case-insensitive)
    title = django_filters.CharFilter(lookup_expr='icontains')
    
    # Filter by caption containing text (case-insensitive)
    caption = django_filters.CharFilter(lookup_expr='icontains')
    
    # Filter by author username
    author = django_filters.CharFilter(field_name='author__username', lookup_expr='icontains')
    
    # Date range filters
    created_after = django_filters.DateTimeFilter(field_name='created_at', lookup_expr='gte')
    created_before = django_filters.DateTimeFilter(field_name='created_at', lookup_expr='lte')
    
    # Filter posts with minimum number of likes
    min_likes = django_filters.NumberFilter(method='filter_by_likes_count')

    class Meta:
        model = Post
        fields = ['title', 'caption', 'author', 'created_after', 'created_before']

    def filter_by_likes_count(self, queryset, name, value):
        """Custom filter method for minimum likes count"""
        from django.db.models import Count
        return queryset.annotate(likes_count=Count('likes')).filter(likes_count__gte=value)

# =======================
# blog/views.py
# =======================
"""
Views handle HTTP requests and return responses.
DRF provides different types of views for different use cases.
"""

from rest_framework import viewsets, status, generics
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework.permissions import AllowAny, IsAuthenticated, IsAuthenticatedOrReadOnly
from rest_framework_simplejwt.tokens import RefreshToken
from django.shortcuts import get_object_or_404
from django.db.models import Q
from django_filters.rest_framework import DjangoFilterBackend
from rest_framework import filters

from .models import CustomUser, Post, Like, Comment
from .serializers import (
    UserRegistrationSerializer, UserLoginSerializer, UserSerializer,
    PostSerializer, CommentSerializer, LikeSerializer
)
from .permissions import IsAuthorOrReadOnly
from .filters import PostFilter

# ===============================
# AUTHENTICATION VIEWS (APIView)
# ===============================

class RegisterView(APIView):
    """
    User registration endpoint.
    APIView gives us full control over the HTTP methods.
    """
    permission_classes = [AllowAny]  # Anyone can register

    def post(self, request):
        """Handle POST request for user registration"""
        serializer = UserRegistrationSerializer(data=request.data)
        if serializer.is_valid():
            # Create the user
            user = serializer.save()
            
            # Generate JWT tokens for the new user
            refresh = RefreshToken.for_user(user)
            
            return Response({
                'user': UserSerializer(user).data,
                'refresh': str(refresh),
                'access': str(refresh.access_token),
                'message': 'User registered successfully'
            }, status=status.HTTP_201_CREATED)
        
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

class LoginView(APIView):
    """
    User login endpoint.
    Returns JWT tokens upon successful authentication.
    """
    permission_classes = [AllowAny]  # Anyone can attempt to login

    def post(self, request):
        """Handle POST request for user login"""
        serializer = UserLoginSerializer(data=request.data)
        if serializer.is_valid():
            user = serializer.validated_data['user']
            
            # Generate JWT tokens
            refresh = RefreshToken.for_user(user)
            
            return Response({
                'user': UserSerializer(user).data,
                'refresh': str(refresh),
                'access': str(refresh.access_token),
                'message': 'Login successful'
            }, status=status.HTTP_200_OK)
        
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

class ProfileView(APIView):
    """
    User profile endpoint.
    GET: Retrieve current user's profile
    PUT: Update current user's profile
    """
    permission_classes = [IsAuthenticated]  # Only authenticated users

    def get(self, request):
        """Get current user's profile"""
        serializer = UserSerializer(request.user)
        return Response(serializer.data)

    def put(self, request):
        """Update current user's profile"""
        serializer = UserSerializer(request.user, data=request.data, partial=True)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

# ===============================
# BLOG VIEWS (ModelViewSet)
# ===============================

class PostViewSet(viewsets.ModelViewSet):
    """
    ViewSet for Post model.
    ModelViewSet provides CRUD operations automatically:
    - GET /posts/ (list all posts)
    - POST /posts/ (create new post)
    - GET /posts/{id}/ (retrieve specific post)
    - PUT /posts/{id}/ (update specific post)
    - DELETE /posts/{id}/ (delete specific post)
    """
    queryset = Post.objects.all()
    serializer_class = PostSerializer
    permission_classes = [IsAuthenticatedOrReadOnly, IsAuthorOrReadOnly]
    
    # Add filtering and search capabilities
    filter_backends = [DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter]
    filterset_class = PostFilter
    search_fields = ['title', 'caption', 'author__username']  # Fields to search in
    ordering_fields = ['created_at', 'likes_count']  # Fields that can be used for ordering
    ordering = ['-created_at']  # Default ordering

    def get_queryset(self):
        """
        Override queryset to add custom filtering.
        This method is called to get the base queryset for the view.
        """
        queryset = Post.objects.all()
        
        # Custom search functionality
        search_query = self.request.query_params.get('search', None)
        if search_query:
            queryset = queryset.filter(
                Q(title__icontains=search_query) |
                Q(caption__icontains=search_query) |
                Q(author__username__icontains=search_query)
            )
        
        return queryset

    def perform_create(self, serializer):
        """
        Set the author of the post to the current user.
        This method is called when creating a new post.
        """
        serializer.save(author=self.request.user)

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def like(self, request, pk=None):
        """
        Custom action to like/unlike a post.
        @action decorator creates a custom endpoint: /posts/{id}/like/
        detail=True means this action works on a specific post instance
        """
        post = self.get_object()  # Get the specific post
        like, created = Like.objects.get_or_create(user=request.user, post=post)
        
        if created:
            # Like was created (user liked the post)
            return Response({
                'message': 'Post liked successfully',
                'is_liked': True,
                'likes_count': post.likes_count
            }, status=status.HTTP_201_CREATED)
        else:
            # Like already existed, so remove it (unlike)
            like.delete()
            return Response({
                'message': 'Post unliked successfully',
                'is_liked': False,
                'likes_count': post.likes_count
            }, status=status.HTTP_200_OK)

    @action(detail=True, methods=['get'])
    def likes(self, request, pk=None):
        """
        Get all likes for a specific post.
        Custom endpoint: /posts/{id}/likes/
        """
        post = self.get_object()
        likes = Like.objects.filter(post=post)
        serializer = LikeSerializer(likes, many=True)
        return Response(serializer.data)

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def comment(self, request, pk=None):
        """
        Add a comment to a specific post.
        Custom endpoint: /posts/{id}/comment/
        """
        post = self.get_object()
        serializer = CommentSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save(user=request.user, post=post)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

    @action(detail=True, methods=['get'])
    def comments(self, request, pk=None):
        """
        Get all comments for a specific post.
        Custom endpoint: /posts/{id}/comments/
        """
        post = self.get_object()
        comments = Comment.objects.filter(post=post)
        serializer = CommentSerializer(comments, many=True)
        return Response(serializer.data)

class CommentViewSet(viewsets.ModelViewSet):
    """
    ViewSet for Comment model.
    Provides full CRUD operations for comments.
    """
    serializer_class = CommentSerializer
    permission_classes = [IsAuthenticatedOrReadOnly, IsAuthorOrReadOnly]
    filter_backends = [filters.SearchFilter, filters.OrderingFilter]
    search_fields = ['content', 'user__username']
    ordering_fields = ['created_at']
    ordering = ['-created_at']

    def get_queryset(self):
        """Get comments, optionally filtered by post"""
        queryset = Comment.objects.all()
        post_id = self.request.query_params.get('post', None)
        if post_id:
            queryset = queryset.filter(post=post_id)
        return queryset

    def perform_create(self, serializer):
        """Set the user when creating a comment"""
        post_id = self.request.data.get('post')
        post = get_object_or_404(Post, id=post_id)
        serializer.save(user=self.request.user, post=post)

class UserListView(generics.ListAPIView):
    """
    List all users with search functionality.
    Using ListAPIView for read-only list of users.
    """
    queryset = CustomUser.objects.all()
    serializer_class = UserSerializer
    permission_classes = [IsAuthenticatedOrReadOnly]
    filter_backends = [filters.SearchFilter, filters.OrderingFilter]
    search_fields = ['username', 'email', 'bio']
    ordering_fields = ['date_joined', 'username']
    ordering = ['-date_joined']

# =======================
# blog/urls.py
# =======================
"""
URL configuration for the blog app.
Includes all API endpoints.
"""

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from rest_framework_simplejwt.views import TokenRefreshView
from .views import (
    RegisterView, LoginView, ProfileView,
    PostViewSet, CommentViewSet, UserListView
)

# DRF Router automatically generates URLs for ViewSets
router = DefaultRouter()
router.register(r'posts', PostViewSet)      # /api/posts/
router.register(r'comments', CommentViewSet) # /api/comments/

urlpatterns = [
    # Authentication endpoints (using APIView)
    path('auth/register/', RegisterView.as_view(), name='register'),
    path('auth/login/', LoginView.as_view(), name='login'),
    path('auth/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
    path('auth/profile/', ProfileView.as_view(), name='profile'),
    
    # User list endpoint
    path('users/', UserListView.as_view(), name='user-list'),
    
    # Include router URLs (ViewSet endpoints)
    path('', include(router.urls)),
]

# =======================
# blog/admin.py
# =======================
"""
Django admin configuration.
Registers models with the admin interface for easy management.
"""

from django.contrib import admin
from django.contrib.auth.admin import UserAdmin
from .models import CustomUser, Post, Like, Comment

@admin.register(CustomUser)
class CustomUserAdmin(UserAdmin):
    """Admin configuration for CustomUser model"""
    list_display = ('username', 'email', 'is_staff', 'date_joined')
    list_filter = ('is_staff', 'is_superuser', 'is_active', 'date_joined')
    search_fields = ('username', 'email', 'bio')
    
    # Add our custom fields to the admin form
    fieldsets = UserAdmin.fieldsets + (
        ('Additional Info', {'fields': ('bio', 'profile_picture')}),
    )
    
    # Fields to show when creating a new user
    add_fieldsets = UserAdmin.add_fieldsets + (
        ('Additional Info', {'fields': ('email', 'bio', 'profile_picture')}),
    )

@admin.register(Post)
class PostAdmin(admin.ModelAdmin):
    """Admin configuration for Post model"""
    list_display = ('id', 'title', 'author', 'created_at', 'likes_count', 'comments_count')
    list_filter = ('created_at', 'author')
    search_fields = ('title', 'caption', 'author__username')
    readonly_fields = ('created_at', 'updated_at', 'likes_count', 'comments_count')
    
    # Fields to display in the form
    fields = ('author', 'title', 'image', 'caption', 'created_at', 'updated_at', 
              'likes_count', 'comments_count')

@admin.register(Like)
class LikeAdmin(admin.ModelAdmin):
    """Admin configuration for Like model"""
    list_display = ('id', 'user', 'post', 'created_at')
    list_filter = ('created_at',)
    search_fields = ('user__username', 'post__title')
    readonly_fields = ('created_at',)

@admin.register(Comment)
class CommentAdmin(admin.ModelAdmin):
    """Admin configuration for Comment model"""
    list_display = ('id', 'user', 'post', 'content_preview', 'created_at')
    list_filter = ('created_at',)
    search_fields = ('content', 'user__username', 'post__title')
    readonly_fields = ('created_at', 'updated_at')
    
    def content_preview(self, obj):
        """Show first 50 characters of comment content"""
        return obj.content[:50] + "..." if len(obj.content) > 50 else obj.content
    content_preview.short_description = "Content Preview"

# =======================
# requirements.txt
# =======================
"""
Required Python packages for the project.
Install with: pip install -r requirements.txt
"""

Django==4.2.7
djangorestframework==3.14.0
djangorestframework-simplejwt==5.3.0
django-cors-headers==4.3.1
django-filter==23.3
Pillow==10.1.0

# =======================
# Project Setup Instructions
# =======================
"""
COMPLETE SETUP GUIDE FOR BEGINNERS

1. CREATE PROJECT STRUCTURE:
   mkdir blog_project
   cd blog_project
   django-admin startproject blog_project .
   python manage.py startapp blog

2. INSTALL DEPENDENCIES:
   pip install Django==4.2.7 djangorestframework==3.14.0 djangorestframework-simplejwt==5.3.0 django-cors-headers==4.3.1 django-filter==23.3 Pillow==10.1.0

3. REPLACE FILES:
   - Replace blog_project/settings.py with the settings.py content above
   - Replace blog_project/urls.py with the urls.py content above
   - Create blog/models.py with the models content above
   - Create blog/serializers.py with the serializers content above
   - Create blog/views.py with the views content above
   - Create blog/permissions.py with the permissions content above
   - Create blog/filters.py with the filters content above
   - Create blog/urls.py with the urls content above
   - Replace blog/admin.py with the admin content above

4. RUN MIGRATIONS:
   python manage.py makemigrations blog
   python manage.py migrate

5. CREATE SUPERUSER:
   python manage.py createsuperuser

6. RUN SERVER:
   python manage.py runserver

7. TEST API ENDPOINTS:
   - Admin: http://127.0.0.1:8000/admin/
   - API Root: http://127.0.0.1:8000/api/
"""

# =======================
# API ENDPOINTS DOCUMENTATION
# =======================
"""
COMPLETE API ENDPOINTS GUIDE

AUTHENTICATION ENDPOINTS:
POST /api/auth/register/
- Register new user
- Body: {"username": "user", "email": "user@email.com", "password": "pass123", "password_confirm": "pass123"}
- Returns: user data + JWT tokens

POST /api/auth/login/
- Login user
- Body: {"email": "user@email.com", "password": "pass123"}
- Returns: user data + JWT tokens

POST /api/auth/token/refresh/
- Refresh access token
- Body: {"refresh": "refresh_token_here"}
- Returns: new access token

GET /api/auth/profile/
- Get current user profile
- Headers: {"Authorization": "Bearer access_token_here"}
- Returns: user profile data

PUT /api/auth/profile/
- Update current user profile
- Headers: {"Authorization": "Bearer access_token_here"}
- Body: {"bio": "New bio", "username": "newname"}

BLOG ENDPOINTS:
GET /api/posts/
- List all posts with pagination
- Query params: 
  - ?search=keyword (search in title, caption, author)
  - ?title=text (filter by title)
  - ?author=username (filter by author)
  - ?ordering=-created_at (order by date)
  - ?page=2 (pagination)

POST /api/posts/
- Create new post
- Headers: {"Authorization": "Bearer access_token_here"}
- Body: {"title": "Post Title", "caption": "Post content", "image": file}

GET /api/posts/{id}/
- Get specific post with comments and likes

PUT /api/posts/{id}/
- Update post (only author can do this)
- Headers: {"Authorization": "Bearer access_token_here"}

DELETE /api/posts/{id}/
- Delete post (only author can do this)

POST /api/posts/{id}/like/
- Like/unlike a post
- Headers: {"Authorization": "Bearer access_token_here"}
- Returns: like status and count

GET /api/posts/{id}/likes/
- Get all likes for a post

POST /api/posts/{id}/comment/
- Add comment to post
- Headers: {"Authorization": "Bearer access_token_here"}
- Body: {"content": "Comment text"}

GET /api/posts/{id}/comments/
- Get all comments for a post

COMMENT ENDPOINTS:
GET /api/comments/
- List all comments
- Query params: ?post=post_id (filter by post)

PUT /api/comments/{id}/
- Update comment (only comment author)

DELETE /api/comments/{id}/
- Delete comment (only comment author)

USER ENDPOINTS:
GET /api/users/
- List all users
- Query params: ?search=username (search users)

SEARCH EXAMPLES:
- Search posts: /api/posts/?search=django
- Filter by author: /api/posts/?author=john
- Order by date: /api/posts/?ordering=-created_at
- Multiple filters: /api/posts/?search=python&ordering=-created_at&page=2
"""

# =======================
# JWT AUTHENTICATION GUIDE
# =======================
"""
HOW JWT AUTHENTICATION WORKS:

1. USER REGISTRATION/LOGIN:
   - User registers or logs in
   - Server returns access_token and refresh_token
   - Access token expires in 1 hour
   - Refresh token expires in 7 days

2. MAKING AUTHENTICATED REQUESTS:
   - Include access token in headers:
     Authorization: Bearer your_access_token_here

3. TOKEN REFRESH:
   - When access token expires, use refresh token
   - POST /api/auth/token/refresh/ with refresh token
   - Get new access token

4. FRONTEND USAGE EXAMPLE (JavaScript):
   
   // Login
   const loginResponse = await fetch('/api/auth/login/', {
     method: 'POST',
     headers: {'Content-Type': 'application/json'},
     body: JSON.stringify({email: 'user@email.com', password: 'pass123'})
   });
   const {access, refresh} = await loginResponse.json();
   
   // Store tokens
   localStorage.setItem('access_token', access);
   localStorage.setItem('refresh_token', refresh);
   
   // Make authenticated request
   const response = await fetch('/api/posts/', {
     headers: {'Authorization': `Bearer ${localStorage.getItem('access_token')}`}
   });
   
   // Handle token refresh
   if (response.status === 401) {
     const refreshResponse = await fetch('/api/auth/token/refresh/', {
       method: 'POST',
       headers: {'Content-Type': 'application/json'},
       body: JSON.stringify({refresh: localStorage.getItem('refresh_token')})
     });
     const {access} = await refreshResponse.json();
     localStorage.setItem('access_token', access);
   }
"""

# =======================
# DJANGO REST FRAMEWORK LEARNING GUIDE
# =======================
"""
DRF CONCEPTS EXPLAINED:

1. SERIALIZERS:
   - Convert Python objects to JSON and vice versa
   - Handle validation of incoming data
   - Define what fields are exposed in API
   - Types: ModelSerializer, Serializer, ListSerializer

2. VIEWS:
   - Handle HTTP requests (GET, POST, PUT, DELETE)
   - Types:
     * APIView: Full control, define methods manually
     * GenericView: Pre-built common patterns
     * ViewSet: Full CRUD operations automatically
     * ModelViewSet: Complete CRUD for a model

3. PERMISSIONS:
   - Control who can access what
   - Built-in: AllowAny, IsAuthenticated, IsAuthenticatedOrReadOnly
   - Custom: Create your own permission classes

4. AUTHENTICATION:
   - How users prove their identity
   - Types: Token, JWT, Session, Basic
   - JWT is stateless and scalable

5. FILTERING & SEARCH:
   - django-filter: Complex filtering
   - SearchFilter: Simple text search
   - OrderingFilter: Sort results

6. PAGINATION:
   - Split large result sets into pages
   - Types: PageNumberPagination, LimitOffsetPagination

7. VIEWSET ACTIONS:
   - @action decorator creates custom endpoints
   - detail=True: works on specific object (/posts/1/like/)
   - detail=False: works on collection (/posts/trending/)

8. URL ROUTING:
   - Router automatically creates URLs for ViewSets
   - Manual URLs for APIViews
   - Nested routing for related resources

BEST PRACTICES:
- Use ModelViewSet for standard CRUD operations
- Use APIView for custom logic
- Always validate data in serializers
- Use appropriate permissions
- Handle errors gracefully
- Document your API
- Use pagination for large datasets
- Implement proper search and filtering
"""

# =======================
# TESTING EXAMPLES
# =======================
"""
MANUAL API TESTING WITH CURL:

1. Register User:
curl -X POST http://127.0.0.1:8000/api/auth/register/ \
  -H "Content-Type: application/json" \
  -d '{"username":"testuser","email":"test@email.com","password":"testpass123","password_confirm":"testpass123"}'

2. Login:
curl -X POST http://127.0.0.1:8000/api/auth/login/ \
  -H "Content-Type: application/json" \
  -d '{"email":"test@email.com","password":"testpass123"}'

3. Create Post (replace TOKEN with actual token):
curl -X POST http://127.0.0.1:8000/api/posts/ \
  -H "Authorization: Bearer TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"title":"My First Post","caption":"This is my first blog post!"}'

4. Search Posts:
curl "http://127.0.0.1:8000/api/posts/?search=first"

5. Like Post:
curl -X POST http://127.0.0.1:8000/api/posts/1/like/ \
  -H "Authorization: Bearer TOKEN"

6. Add Comment:
curl -X POST http://127.0.0.1:8000/api/posts/1/comment/ \
  -H "Authorization: Bearer TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"content":"Great post!"}'
"""